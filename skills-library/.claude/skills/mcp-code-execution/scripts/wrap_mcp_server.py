#!/usr/bin/env python3
"""
MCP Code Execution - MCP Server Wrapper
Converts MCP servers to code execution pattern for token efficiency.
"""

import os
import sys
import argparse
import json
import subprocess
from pathlib import Path


def create_wrapper_script(mcp_server_url, output_dir, service_name):
    """Create a wrapper script for the MCP server."""

    wrapper_content = f'''#!/usr/bin/env python3
"""
Wrapper script for {service_name} MCP server
Generated by MCP Code Execution pattern.
"""

import requests
import json
import sys
from typing import Dict, Any, Optional


def call_{service_name.lower()}_api(endpoint: str, method: str = "GET", data: Optional[Dict] = None) -> Dict[Any, Any]:
    """
    Call the {service_name} API via the MCP server wrapper.
    This function filters data before returning to context for token efficiency.
    """
    mcp_server_url = "{mcp_server_url}"

    try:
        headers = {{
            "Content-Type": "application/json"
        }}

        if method.upper() == "GET":
            response = requests.get(f"{{mcp_server_url}}{{endpoint}}", headers=headers)
        elif method.upper() == "POST":
            response = requests.post(f"{{mcp_server_url}}{{endpoint}}", headers=headers, json=data)
        elif method.upper() == "PUT":
            response = requests.put(f"{{mcp_server_url}}{{endpoint}}", headers=headers, json=data)
        elif method.upper() == "DELETE":
            response = requests.delete(f"{{mcp_server_url}}{{endpoint}}", headers=headers)
        else:
            raise ValueError(f"Unsupported method: {{method}}")

        response.raise_for_status()
        return response.json()

    except requests.exceptions.RequestException as e:
        print(f"Error calling {service_name} API: {{e}}", file=sys.stderr)
        return {{"error": str(e)}}


def filter_response_data(response_data: Dict) -> Dict:
    """
    Filter the response data to return only essential information for token efficiency.
    Customize this function based on your specific {service_name} use case.
    """
    # Example: Only return essential fields
    if isinstance(response_data, dict):
        # Customize filtering based on {service_name} response structure
        filtered = {{}}

        # Common fields to preserve
        for key in ["id", "name", "status", "result", "success", "message"]:
            if key in response_data:
                filtered[key] = response_data[key]

        # If there are items in the response, filter each item
        if "items" in response_data and isinstance(response_data["items"], list):
            filtered["items"] = []
            for item in response_data["items"]:
                if isinstance(item, dict):
                    filtered_item = {{}}
                    for key in ["id", "name", "type", "status", "title"]:
                        if key in item:
                            filtered_item[key] = item[key]
                    filtered["items"].append(filtered_item)
                else:
                    # If item is not a dict, just include it
                    filtered["items"].append(item)

        return filtered
    else:
        # If response is not a dict, return as-is (might be a simple value)
        return response_data


def main():
    """Main function to execute {service_name} operations."""
    if len(sys.argv) < 2:
        print(f"Usage: {{sys.argv[0]}} <operation> [args...]", file=sys.stderr)
        print("Operations: get_resource, list_resources, create_resource, etc.")
        return 1

    operation = sys.argv[1]

    # Example operations - customize based on your {service_name} MCP server
    if operation == "get_resource":
        if len(sys.argv) < 3:
            print("Usage: get_resource <resource_id>", file=sys.stderr)
            return 1

        resource_id = sys.argv[2]
        endpoint = f"/resources/{{resource_id}}"
        response = call_{service_name.lower()}_api(endpoint, "GET")
        filtered_response = filter_response_data(response)
        print(json.dumps(filtered_response))

    elif operation == "list_resources":
        endpoint = "/resources"
        response = call_{service_name.lower()}_api(endpoint, "GET")
        filtered_response = filter_response_data(response)
        print(json.dumps(filtered_response))

    elif operation == "create_resource":
        if len(sys.argv) < 3:
            print("Usage: create_resource <json_data>", file=sys.stderr)
            return 1

        try:
            data = json.loads(sys.argv[2])
            endpoint = "/resources"
            response = call_{service_name.lower()}_api(endpoint, "POST", data)
            filtered_response = filter_response_data(response)
            print(json.dumps(filtered_response))
        except json.JSONDecodeError as e:
            print(f"Invalid JSON data: {{e}}", file=sys.stderr)
            return 1

    else:
        print(f"Unknown operation: {{operation}}", file=sys.stderr)
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
'''

    # Write the wrapper script
    wrapper_path = Path(output_dir) / f"{service_name.lower()}_wrapper.py"
    with open(wrapper_path, 'w') as f:
        f.write(wrapper_content)

    # Make it executable
    wrapper_path.chmod(0o755)

    print(f"âœ“ Created wrapper script: {wrapper_path}")
    return wrapper_path


def main():
    """Main function to generate MCP wrapper."""
    parser = argparse.ArgumentParser(description="Convert MCP server to code execution pattern")
    parser.add_argument("mcp_server_url", help="URL of the MCP server to wrap")
    parser.add_argument("service_name", help="Name of the service to wrap")
    parser.add_argument("--output-dir", "-o", default=".", help="Output directory for the wrapper")

    args = parser.parse_args()

    # Create output directory if it doesn't exist
    output_path = Path(args.output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # Create the wrapper script
    wrapper_path = create_wrapper_script(args.mcp_server_url, output_path, args.service_name)

    print(f"\nWrapper created successfully!")
    print(f"Token efficiency achieved: MCP server wrapped in minimal script")
    print(f"Use: python {wrapper_path} <operation> to interact with the service")

    return 0


if __name__ == "__main__":
    sys.exit(main())